<h1 id="deletecmd"><a aria-hidden="true" class="anchor-heading icon-link" href="#deletecmd"></a>deleteCmd</h1>
<p>import {
DLink,
DVault,
EngineDeletePayload,
normalizeUnixPath,
NoteProps,
NoteUtils,
Position,
ReducedDEngine,
VaultUtils,
} from "@dendronhq/common-all";
import { RemarkUtils } from "@dendronhq/unified";
import _ from "lodash";
import _md from "markdown-it";
import { inject, injectable } from "tsyringe";
import {
commands,
TextEditor,
Uri,
ViewColumn,
window,
workspace,
} from "vscode";
import { URI, Utils } from "vscode-uri";
import { DENDRON_COMMANDS } from "../../constants";
import { isPathInWorkspace } from "../utils/isPathInWorkspace";</p>
<p>type CommandOpts = any;</p>
<p>type CommandOutput = EngineDeletePayload | void;
export type { CommandOutput as DeleteNodeCommandOutput };</p>
<p>// function formatDeletedMsg({
//   fsPath,
//   vault,
// }: {
//   fsPath: string;
//   vault: DVault;
// }) {
//   return <code>${Utils.basename(Uri.file(fsPath))} (${VaultUtils.getName( //     vault //   )}) deleted</code>;
// }</p>
<p><a title="Private" href="https://wiki.dendron.so/notes/hfyvYGJZQiUwQaaxQO27q.html" target="_blank" class="private">@injectable (Private)</a>()
export class DeleteCmd {
constructor(
<a title="Private" href="https://wiki.dendron.so/notes/hfyvYGJZQiUwQaaxQO27q.html" target="_blank" class="private">@inject (Private)</a>("wsRoot") private wsRoot: URI,
<a title="Private" href="https://wiki.dendron.so/notes/hfyvYGJZQiUwQaaxQO27q.html" target="_blank" class="private">@inject (Private)</a>("ReducedDEngine")
private engine: ReducedDEngine,
<a title="Private" href="https://wiki.dendron.so/notes/hfyvYGJZQiUwQaaxQO27q.html" target="_blank" class="private">@inject (Private)</a>("vaults") private vaults: DVault[]
) {}</p>
<p>  key = DENDRON_COMMANDS.DELETE.key;</p>
<p>  private async getBacklinkFrontmatterLineOffset(opts: { link: DLink }) {
const { link } = opts;
const vault = VaultUtils.getVaultByName({
vaults: this.vaults,
vname: link.from.vaultName as string,
}) as DVault;
const noteWithLink = (
await this.engine.findNotes({ fname: link.from.fname, vault })
)[0];
const fsPath = NoteUtils.getFullPath({
note: noteWithLink,
wsRoot: this.wsRoot.fsPath,
});
console.log("fsPath<strong>**</strong>", fsPath);
const fileContent = workspace.fs.readFile(Uri.file(fsPath)).toString();
const nodePosition = RemarkUtils.getNodePositionPastFrontmatter(
fileContent
) as Position;</p>
<pre><code>return nodePosition?.end.line;
</code></pre>
<p>  }
/**</p>
<ul>
<li>
<p>When Delete Command is ran from explorer menu, it gets Uri as args
*/
private isUriArgs(opts: CommandOpts) {
return !_.isEmpty(opts) &#x26;&#x26; opts.fsPath;
}</p>
<p>  private async deleteNote(params: {
note: NoteProps;
opts: CommandOpts;
ctx: string;
}) {
const { note, opts } = params;
const backlinks = note.links.filter((link) => link.type === "backlink");
let title;
if (backlinks.length === 0) {
// no need to show preview a simple
title = <code>Delete note ${note.fname}?</code>;
} else {
await this.showNoteDeletePreview(note, backlinks);
title = <code>${note.fname} has backlinks. Delete note?</code>;
}</p>
<pre><code>const shouldProceed = await this.promptConfirmation(title, opts?.noConfirm);
if (!shouldProceed) {
  window.showInformationMessage("Cancelled");
  return;
}

// If Delete note preview is open, close it first
if (backlinks.length !== 0) {
  await commands.executeCommand("workbench.action.closeActiveEditor");
}

const out = (await this.engine.deleteNote(note.id)) as EngineDeletePayload;
if (out.error) {
  return;
}
// window.showInformationMessage(
//   formatDeletedMsg({ fsPath: note.fname, vault: note.vault })
// );
await commands.executeCommand("workbench.action.closeActiveEditor");
return out;
</code></pre>
<p>  }</p>
<p>  async showNoteDeletePreview(note: NoteProps, backlinks: DLink[]) {
let content = [
"# Delete Node Preview",
"<code>",       `node type: note`,       "",       `# of backlinks to this note: ${backlinks.length}`,       "</code>",
"## Broken links after deletion",
<code>These links will be broken after deleting **${note.fname}**</code>,
"",
<code>Make sure to convert the broken links listed below accordingly.</code>,
"",
];</p>
<pre><code>_.forEach(_.sortBy(backlinks, ["from.vaultName"]), async (backlink) => {
  const fmLineOffset = await this.getBacklinkFrontmatterLineOffset({
    link: backlink,
  });
  const entry = [
    `- in **${backlink.from.vaultName}/${backlink.from.fname}**`,
    `  - line *${backlink.position!.start.line + fmLineOffset}* column *${
      backlink.position?.start.column
    }*`,
    `  - alias: \`${backlink.alias ? backlink.alias : "None"}\``,
  ].join("\n");
  content = content.concat(entry);
});

const panel = window.createWebviewPanel(
  "deleteNodeNoteDeletePreview",
  "Note Delete Preview",
  ViewColumn.One,
  {}
);
panel.webview.html = _md().render(content.join("\n"));
return content.join("\n");
</code></pre>
<p>  }</p>
<p>  async promptConfirmation(title: string, noConfirm?: boolean) {
if (noConfirm) return true;
const options = ["Proceed", "Cancel"];
const resp = await window.showQuickPick(options, {
title,
placeHolder: "Proceed",
ignoreFocusOut: true,
});
return resp === "Proceed";
}</p>
<p>  async sanityCheck(opts?: CommandOpts) {
if (<em>.isUndefined(window.activeTextEditor) &#x26;&#x26; </em>.isEmpty(opts)) {
return "No note currently open, and no note selected to open.";
}
return;
}</p>
<p>  async run(opts?: CommandOpts): Promise<commandoutput> {
const ctx = "DeleteNoteCommand";
if (NoteUtils.isNoteProps(opts)) {
const out = this.deleteNote({ note: opts, opts, ctx });
return out;
} else {
const editor = window.activeTextEditor as TextEditor;
const path = this.isUriArgs(opts) ? opts : editor.document.uri;
const mode = path.fsPath.endsWith(".md") ? "note" : "schema";
const trimEnd = mode === "note" ? ".md" : ".schema.yml";
const fname = _.trimEnd(Utils.basename(path), trimEnd);
if (mode === "note") {
const vault = this.getVaultForOpenEditor(path.fsPath);
const note = (await this.engine.findNotes({ fname, vault }))[0];
const out = await this.deleteNote({ note, opts, ctx });
return out;
} else {
window.showInformationMessage("schema delete not implemented yet");
}
}
}
getVaultForOpenEditor(fsPath: any) {
let vault: DVault;
const activeDocument = window.activeTextEditor?.document;
const fpath = fsPath || activeDocument?.uri.fsPath;
console.log("fpath", fpath, normalizeUnixPath(fpath));
if (
fpath &#x26;&#x26;
isPathInWorkspace({
wsRoot: this.wsRoot,
vaults: this.vaults,
fsPath: activeDocument?.uri!,
})
) {
vault = VaultUtils.getVaultByFilePath({
vaults: this.vaults,
wsRoot: normalizeUnixPath(this.wsRoot.fsPath),
fsPath: normalizeUnixPath(fpath),
});
} else {
vault = this.vaults[0];
}
return vault;
}
}</commandoutput></p>
</li>
</ul>